//=============================================================================
// ■ FM::BinaryIndexedTree
//-----------------------------------------------------------------------------
//   树状数组的类。树状数组又以其发明者命名为Fenwick树。
//=============================================================================

template <class T, size_t size, T initial_value> class BinaryIndexedTree {
	//-------------------------------------------------------------------------
	// ● 定义
	//-------------------------------------------------------------------------
	T data_array[size];
	T* const data = data_array - 1;
public:
	// operation是一种具有结合性的二元运算。
	// 通常，为了求前n项和而建立的树状数组对应的运算是二元加法：
	//     [] (int* a, const int* b) { *a += *b; }
	typedef void (*type_operation)(T* a, const T* b);
	type_operation operation;
	//-------------------------------------------------------------------------
	// ● 最低非零位
	//-------------------------------------------------------------------------
	static size_t lowbit(size_t x) {
		return x & -x;
	}
	//-------------------------------------------------------------------------
	// ● 初始化
	//-------------------------------------------------------------------------
	BinaryIndexedTree(type_operation initial_operation) {
		operation = initial_operation;
		for (size_t i = 1; i <= size; i++) data[i] = initial_value;
	}
	//-------------------------------------------------------------------------
	// ● 对第i项操作
	//-------------------------------------------------------------------------
	void operate(size_t i, T x) {
		while (i < size) {
			operation(&data[i], &x);
			i += lowbit(i);
		}
	}
	//-------------------------------------------------------------------------
	// ● 求前n项和
	//-------------------------------------------------------------------------
	T sum(size_t n) {
		T r = initial_value;
		while (n) {
			operation(&r, &data[n]);
			n &= ~lowbit(n);
		}
		return r;
	}
};
