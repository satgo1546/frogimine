//=============================================================================
// ■ FM::BinaryHeap
//-----------------------------------------------------------------------------
//   二叉堆。
//=============================================================================

template <class T, size_t size, bool max_heap> class BinaryHeap {
	//-------------------------------------------------------------------------
	// ● 定义
	//-------------------------------------------------------------------------
	T data_array[size];
	T* const data = data_array - 1;
public:
	// 已经使用了的元素计数
	size_t count;
	//-------------------------------------------------------------------------
	// ● 初始化
	//-------------------------------------------------------------------------
	BinaryHeap() {
		count = 0;
	}
	//-------------------------------------------------------------------------
	// ● 元素是否按照堆的顺序排列？
	//-------------------------------------------------------------------------
	inline bool is_ordered(T parent, T child) {
		return max_heap ? parent > child : parent < child;
	}
	//-------------------------------------------------------------------------
	// ● 取根元素
	//-------------------------------------------------------------------------
	T root() {
		return data[1];
	}
	//-------------------------------------------------------------------------
	// ● 向上调整
	//-------------------------------------------------------------------------
	void sift_up() {
		size_t i = count;
		while (i > 1 && !is_ordered(data[i >> 1], data[i])) {
			T tmp = data[i >> 1];
			data[i >> 1] = data[i];
			data[i] = tmp;
			i >>= 1;
		}
	}
	//-------------------------------------------------------------------------
	// ● 插入
	//-------------------------------------------------------------------------
	void insert(T x) {
		count++;
		data[count] = x;
		sift_up();
	}
	//-------------------------------------------------------------------------
	// ● 向下调整
	//-------------------------------------------------------------------------
	void sift_down() {
		size_t i = 1;
		while (i <= (count >> 1)) {
			size_t j = i << 1;
			size_t k = j | 1;
			if (is_ordered(data[k], data[j])) j = k;
			if (is_ordered(data[j], data[i])) {
				T tmp = data[i];
				data[i] = data[j];
				data[j] = tmp;
				i = j;
			} else {
				break;
			}
		}
	}
	//-------------------------------------------------------------------------
	// ● 删除根元素
	//-------------------------------------------------------------------------
	T pop() {
		T r = data[1];
		data[1] = data[count];
		count--;
		sift_down();
		return r;
	}
	//-------------------------------------------------------------------------
	// ● 删除根元素并插入
	//-------------------------------------------------------------------------
	void replace(T x) {
		data[1] = data[count];
		sift_down();
	}
};
